<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>JAR</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="jar">JAR - 10</h2>
<ul>
<li><details>
<summary>
(2025). Constructing the lie algebra of smooth vector fields on a lie group in Isabelle/HOL. <em>JAR</em>, <em>69</em>(3), 1-29. (<a href='https://doi.org/10.1007/s10817-025-09724-x'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {This paper describes a formal theory of smooth vector fields, Lie groups and the Lie algebra of a Lie group in the theorem prover Isabelle. Lie groups are abstract structures that are composable, invertible and differentiable; they are useful in the study of continuous transformations in fields such as particle physics and robotics. The formalisation of this theory in an interactive theorem prover poses challenges beyond those encountered in textbook developments. We comment on representational choices we made to integrate involved concepts, such as smoothness of vector fields, with the simple type theory of higher-order logic (HOL) and existing material in Isabelle/HOL.},
  archive      = {J_JAR},
  author       = {Schmoetten, Richard and Fleuriot, Jacques D.},
  doi          = {10.1007/s10817-025-09724-x},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-29},
  shortjournal = {J. Auto. Reasoning},
  title        = {Constructing the lie algebra of smooth vector fields on a lie group in Isabelle/HOL},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Active learning for SAT solver benchmarking. <em>JAR</em>, <em>69</em>(3), 1-23. (<a href='https://doi.org/10.1007/s10817-025-09729-6'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Benchmarking is crucial for developing new algorithms. This also applies to solvers for the propositional satisfiability (SAT) problem. Benchmark selection is about choosing representative problem instances that reliably discriminate solvers based on their runtime. In this paper, we present a dynamic benchmark selection approach based on active learning. Our approach estimates the rank of a new solver among its competitors, striving to minimize benchmarking runtime but maximize ranking accuracy. Instead of using real-valued solver runtimes, our approach works with discretized runtime labels, which yielded better solver rank predictions. We evaluated this approach on the Anniversary Track dataset from the SAT Competition 2022. Our benchmark selection approach can predict the rank of a new solver after approximately 10 % of the time it would take to run the solver on all instances of this dataset, with a prediction accuracy of approximately 92 %. Additionally, we discuss the importance of instance families in the selection process. In conclusion, our tool offers a reliable method for solver engineers to assess a new solver’s performance efficiently.},
  archive      = {J_JAR},
  author       = {Fuchs, Tobias and Bach, Jakob and Iser, Markus},
  doi          = {10.1007/s10817-025-09729-6},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-23},
  shortjournal = {J. Auto. Reasoning},
  title        = {Active learning for SAT solver benchmarking},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Double auctions: Formalization and automated checkers. <em>JAR</em>, <em>69</em>(3), 1-33. (<a href='https://doi.org/10.1007/s10817-025-09732-x'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Double auctions are widely used in financial markets, such as those for stocks, derivatives, currencies, and commodities, to match demand and supply. Once all buyers and sellers have placed their trade requests, the exchange determines how these requests are to be matched. The two most common objectives for determining the matching are maximizing trade volume at a uniform price and maximizing trade volume through dynamic pricing. In this work, we present fully formalized matching algorithms for double auctions, along with their correctness proofs. We establish new uniqueness theorems, enabling automatic detection of violations in exchange systems by comparing their output to that of a verified program. All proofs are formalized in the Coq Proof Assistant; we extract verified OCaml and Haskell programs that could serve as a resource for exchanges and market regulators. We demonstrate the practical applicability of our work by running the verified program on real market data from an exchange to automatically check for violations in the exchange algorithm.},
  archive      = {J_JAR},
  author       = {Garg, Mohit and Raja, N. and Sarswat, Suneel and Singh, Abhishek Kr},
  doi          = {10.1007/s10817-025-09732-x},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-33},
  shortjournal = {J. Auto. Reasoning},
  title        = {Double auctions: Formalization and automated checkers},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Automated reasoning for proving non-orderability of groups. <em>JAR</em>, <em>69</em>(3), 1-32. (<a href='https://doi.org/10.1007/s10817-025-09734-9'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We demonstrate how a generic automated theorem prover can be applied to establish the non-orderability of groups. Our approach incorporates various tools such as reasoning from the first principles, positive cones, torsions, generalised torsions and cofinal elements.},
  archive      = {J_JAR},
  author       = {Lisitsa, Alexei and Nie, Zipei and Vernitski, Alexei},
  doi          = {10.1007/s10817-025-09734-9},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-32},
  shortjournal = {J. Auto. Reasoning},
  title        = {Automated reasoning for proving non-orderability of groups},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Solving a problem with GeoGebra current possibilities and limits of CAS tools. <em>JAR</em>, <em>69</em>(3), 1-13. (<a href='https://doi.org/10.1007/s10817-025-09733-w'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In the article we show what a Dynamic Geometry Environment (DGE) and Computer Algebra System (CAS) software is capable of exploring, computing and proving a geometry problem that is closely related to the well-known Wallace-Simson theorem. In our case, this problem turns out to be quite difficult for some software tools incorporated in the DGE software. The computation of a searched locus by the software works well in our case, but the problem must be formulated in a specific way. In addition to the conclusions attained by DGE software, we present computer-aided analytical solutions in the second half of paper. It is shown that the use of non-degeneracy conditions before elimination leads to a significant reduction of the computation time.},
  archive      = {J_JAR},
  author       = {Blažek, Jiří and Pech, Pavel},
  doi          = {10.1007/s10817-025-09733-w},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-13},
  shortjournal = {J. Auto. Reasoning},
  title        = {Solving a problem with GeoGebra current possibilities and limits of CAS tools},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Formally verified suffix array construction. <em>JAR</em>, <em>69</em>(3), 1-38. (<a href='https://doi.org/10.1007/s10817-025-09735-8'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Suffix arrays are a data structure with numerous real-world applications. They are extensively used in text retrieval and data compression applications, including query suggestion mechanisms in web search, and in bioinformatics tools for DNA sequencing and matching. This wide applicability means that algorithms for constructing suffix arrays are of great practical importance. The SA-IS algorithm is an efficient but conceptually complex suffix array construction technique, and implementing it requires a deep understanding of its underlying theory. As a critical step towards developing a provably correct and efficient implementation, we have developed the SA-IS algorithm in Isabelle/HOL and formally verified that it is equivalent to a mathematical functional specification of suffix arrays, a task that required verifying a wide range of underlying properties of strings and suffixes. We also used Isabelle’s code extraction facilities to extract an executable Haskell implementation of SA-IS, which albeit is inefficient due to using lists and natural numbers rather than arrays and machine words, demonstrates that our verified HOL implementation of SA-IS can be refined to an executable implementation in its current form.},
  archive      = {J_JAR},
  author       = {Cheung, Louis and Moffat, Alistair and Rizkallah, Christine},
  doi          = {10.1007/s10817-025-09735-8},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-38},
  shortjournal = {J. Auto. Reasoning},
  title        = {Formally verified suffix array construction},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Structured monads for generic first-order syntax metatheory. <em>JAR</em>, <em>69</em>(3), 1-41. (<a href='https://doi.org/10.1007/s10817-025-09731-y'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Reasoning about substitution remains one of the most tedious and error-prone aspects of formal metatheory. We present Tealeaves, a framework implemented in Coq for developing such infrastructure generically and modularly. Tealeaves is centered on a novel categorical abstraction, decorated traversable monads (DTMs), which provide a unifying foundation for first-order syntax and enable local, compositional reasoning about syntactic operations, such as substitution, that are defined purely by their effect on individual variable occurrences. Within this framework, Tealeaves supports extensible backend modules, each implementing the metatheory of a specific concrete strategy for representing binders. Our current backends include implementations of de Bruijn indices in the style of Autosubst, as well as locally nameless in the style of LNgen. Tealeaves goes further by providing a certified translation between these representations, illustrating how DTMs reconcile their underlying structures. The framework also accommodates challenging features such as variadic and mutually-recursive binders, which are often overlooked by both theoretical treatments and practical tools. We describe the implementation and use of Tealeaves’ backends in formalized language developments, introduce the equational axioms that characterize DTMs, and conclude with a presentation of those axioms instantiated for the lambda calculus extended with a variadic binding constructor.},
  archive      = {J_JAR},
  author       = {Dunn, Lawrence and Tannen, Val and Zdancewic, Steve},
  doi          = {10.1007/s10817-025-09731-y},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-41},
  shortjournal = {J. Auto. Reasoning},
  title        = {Structured monads for generic first-order syntax metatheory},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Reasoning about incompletely defined programs. <em>JAR</em>, <em>69</em>(3), 1-48. (<a href='https://doi.org/10.1007/s10817-025-09722-z'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We consider automated reasoning about recursively defined partial functions with decidable domain, i.e. functions computed by incompletely defined (or underspecified) but terminating functional programs. We define an interpreter for those programs, consider termination and investigate the semantics of incompletely defined programs. The interpreter may halt with a stuck computation, e.g. when dividing a number by zero, which represents a runtime error in a conventional programming environment. We show how so-called domain procedures are synthesized which decide the domain of incompletely defined procedures in almost all cases. As calls of domain procedures occur in proof obligations, domain procedures are optimized to make them as simple as possible. We also use domain procedures to refine the program semantics such that statements causing stuck computations do not hold. Our method to reason about incompletely defined programs is implemented in the verification tool VeriFun.},
  archive      = {J_JAR},
  author       = {Walther, Christoph},
  doi          = {10.1007/s10817-025-09722-z},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-48},
  shortjournal = {J. Auto. Reasoning},
  title        = {Reasoning about incompletely defined programs},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Computing expected visiting times and stationary distributions in markov chains: Fast and accurate. <em>JAR</em>, <em>69</em>(3), 1-50. (<a href='https://doi.org/10.1007/s10817-025-09736-7'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study the accurate and efficient computation of the expected number of times each state is visited in discrete- and continuous-time Markov chains. To obtain sound accuracy guarantees efficiently, we lift interval iteration, optimistic value iteration and topological approaches developed to compute reachability probabilities and expected rewards and prove all these algorithms to be correct. We further establish that expected visiting times are preserved under backward probabilistic bisimilarity. We study various applications of expected visiting times. The reachability probabilities of multiple bottom strongly connected components (BSCCs) can be obtained by solving a single linear equation system—as opposed to solving an equation system per BSCC. Other applications include the sound computation of the stationary distribution as well as expected rewards conditioned on reaching multiple goal states. The implementation of our methods in the probabilistic model checker Storm scales to large systems with millions of states. Our experiments on the quantitative verification benchmark set show that the computation of stationary distributions via expected visiting times consistently outperforms existing approaches—sometimes by several orders of magnitude.},
  archive      = {J_JAR},
  author       = {Mertens, Hannah and Katoen, Joost-Pieter and Quatmann, Tim and Winkler, Tobias},
  doi          = {10.1007/s10817-025-09736-7},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-50},
  shortjournal = {J. Auto. Reasoning},
  title        = {Computing expected visiting times and stationary distributions in markov chains: Fast and accurate},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). LTL reactive synthesis with a few hints. <em>JAR</em>, <em>69</em>(3), 1-50. (<a href='https://doi.org/10.1007/s10817-025-09737-6'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We study a variant of the problem of synthesizing Mealy machines that enforce LTL specifications against all possible behaviours of the environment including hostile ones. In the variant studied here, the user provides the high level LTL specification $$\varphi $$ of the system to design, and a set E of examples of executions that the solution must produce. Our synthesis algorithm works in two phases. First, it generalizes the decisions taken along the examples E using tailored extensions of automata learning algorithms. This phase generalizes the user-provided examples in E while preserving realizability of $$\varphi $$ . Second, the algorithm turns the (usually) incomplete Mealy machine obtained by the learning phase into a complete Mealy machine that realizes $$\varphi $$ . The examples are used to guide the synthesis procedure. We provide a completeness result that shows that our procedure can learn any Mealy machine M that realizes $$\varphi $$ with a small (polynomial) set of examples. We also show that our problem, that generalizes the classical LTL synthesis problem (i.e. when $$E=\emptyset $$ ), matches its worst-case complexity. The additional cost of learning from E is even polynomial in the size of E and in the size of a symbolic representation of solutions that realize $$\varphi $$ . This symbolic representation is computed by the synthesis algorithm implemented in Acacia-Bonzai when solving the plain LTL synthesis problem. We illustrate the practical interest of our approach on a set of examples.},
  archive      = {J_JAR},
  author       = {Balachander, Mrudula and Filiot, Emmanuel and Raskin, Jean-François},
  doi          = {10.1007/s10817-025-09737-6},
  journal      = {Journal of Automated Reasoning},
  month        = {9},
  number       = {3},
  pages        = {1-50},
  shortjournal = {J. Auto. Reasoning},
  title        = {LTL reactive synthesis with a few hints},
  volume       = {69},
  year         = {2025},
}
</textarea>
</details></li>
</ul>

</body>
</html>
