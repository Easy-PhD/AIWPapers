<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <title>TIT</title>
  <style>
    html {font-size: 22px;}
    body {margin: 0 auto; max-width: 76em;}
    #copyID {font-size: 18px;}
  </style>
  <script>
    function copy(element) {
      if (element.type == "button"){
      element.type="text";
      }
      element.style.color="black";
      element.style.backgroundColor="#C7EDCC";
      element.select();
      element.setSelectionRange(0, 99999);
      navigator.clipboard.writeText(element.value);
      window.getSelection().removeAllRanges();
      element.type="button";
    }
  </script>
</head>
<body>

<h2 id="tit">TIT - 4</h2>
<ul>
<li><details>
<summary>
(2025). A novel method to determine low-weight input patterns of recursive systematic convolutional codes. <em>TIT</em>, 1. (<a href='https://doi.org/10.1109/TIT.2025.3616240'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {In this research paper, we present a novel method for obtaining the patterns of inputs that generate low-weight codewords in Recursive Systematic Convolutional (RSC) codes, hereafter referred to as low-weight inputs. RSC codes are commonly used as component codes for various concatenated schemes, including the popular Turbo codes. Efficient interleaver design is crucial in improving the error-correcting performance of Turbo codes; therefore, understanding the low-weight input patterns specific to the selected RSC code is essential. Existing graph-based search algorithms face increasing complexity as the constraint length of the RSC code increases. To address this issue, we introduce a method that directly derives the critical low-weight input patterns (up to Hamming weight 4) from the generator function of the RSC code. The proposed method addresses the complexity issue and can be extended to non-recursive systematic convolutional (NRSC) codes by modifying the generator function. To validate our novel method, we compare the union bound obtained using our approach to that obtained via the transfer function method and the simulation results for selected RSC codes. This comparison demonstrates the effectiveness of our method, which shows no significant counting losses.},
  archive      = {J_TIT},
  author       = {Kwame Ackah Bohulu and Chenggao Han},
  doi          = {10.1109/TIT.2025.3616240},
  journal      = {IEEE Transactions on Information Theory},
  month        = {10},
  pages        = {1},
  shortjournal = {IEEE Trans. Inf. Theory},
  title        = {A novel method to determine low-weight input patterns of recursive systematic convolutional codes},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). YuS: A FHE-friendly stream cipher based on new quadratic permutations. <em>TIT</em>, 1. (<a href='https://doi.org/10.1109/TIT.2025.3616035'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {Permutations with low multiplication depth over prime fields are highly valuable in the design of symmetric ciphers that are compatible with fully homomorphic encryption (FHE). Quadratic permutations, which have the lowest depth, have been widely used in prior designs. In this paper, we propose a construction method that can give new quadratic permutations over Fpm, and cryptographic properties such as differential uniformity and Walsh spectrum of these permutations are also characterized. We give sufficient conditions for permutations over Fpn to attain a differential uniformity of pn−1 for n ≥ 3. Furthermore, it is proven that for these permutations, the maximal 2-norm of Walsh coefficients remains bounded by pn−1, provided either the last n − 1 entries of the input mask or the last n − 1 entries of the output mask form a nonzero vector. As an application, we design a new FHE-friendly stream cipher named YuS based on a new quadratic permutation over Fp3 and a fixed linear mapping. According to our implementation, achieves YuS faster evaluation times and higher throughput compared to Masta, Pasta, Pastav2 and HERA in almost all instances for both BGV and BFV schemes at 80-bit and 128-bit security levels.},
  archive      = {J_TIT},
  author       = {Yongqiang Li and Fangzhen Wang and Xingwei Ren and Fen Liu and Xichao Hu and Lin Jiao and Ya Han},
  doi          = {10.1109/TIT.2025.3616035},
  journal      = {IEEE Transactions on Information Theory},
  month        = {10},
  pages        = {1},
  shortjournal = {IEEE Trans. Inf. Theory},
  title        = {YuS: A FHE-friendly stream cipher based on new quadratic permutations},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Weight structure of Low/High-rate polar codes and weight contribution-based partial order. <em>TIT</em>, 1. (<a href='https://doi.org/10.1109/TIT.2025.3616283'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {The structure of a linear block code is pivotal in defining fundamental properties, particularly weight distribution, and code design. In this study, we characterize the Type II structure of polar codewords with weights less than twice the minimum weight wmin, using the lower triangular affine (LTA) transform. We present a closed-form formula for their enumeration. Leveraging this structure and additionally characterizing the structure of weight 2wmin, we ascertain the complete weight distribution of low-rate polar codes (with minimum distance dmin = 2m−2 where code-length is 2m) and, through the utilization of dual codes properties, high-rate polar codes, subcodes of Reed–Muller (RM) codes, and RM–Polar codes. Furthermore, we introduce a new partial order based on the weight distribution and explore its properties and applications in code construction and analysis.},
  archive      = {J_TIT},
  author       = {Mohammad Rowshan and Vlad-Florin Drăgoi},
  doi          = {10.1109/TIT.2025.3616283},
  journal      = {IEEE Transactions on Information Theory},
  month        = {10},
  pages        = {1},
  shortjournal = {IEEE Trans. Inf. Theory},
  title        = {Weight structure of Low/High-rate polar codes and weight contribution-based partial order},
  year         = {2025},
}
</textarea>
</details></li>
<li><details>
<summary>
(2025). Frame multipliers and compressive sensing. <em>TIT</em>, 1. (<a href='https://doi.org/10.1109/TIT.2025.3616817'>www</a>)
</summary>
<textarea id="copyID" onclick="copy(this)" rows="16" cols="145">
@article{ ,
  abstract     = {We investigate the applicability of frame multipliers as compressive sensing measurements. We show that, under certain conditions, subsampled frame multipliers yield measurement matrices with desirable properties. To that end, we prove a general probabilistic nullspace property for arbitrary nonempty sets, that accounts for the special measurement structure induced by subsampled frame multipliers. Conditions for uniqueness of reconstruction of signals that are sparse with respect to dictionaries or, more generally, to non-linear locally Lipschitz mappings are obtained as special cases. Furthermore, we show that a frame multiplier matrix is full superregular, i.e., that all its minors are nonzero, for almost all frame symbol vectors, provided that the underlying frames are full spark and sufficiently redundant. Since Gabor frames are full spark for almost all windows, we study Gabor multipliers in more detail and are able to derive improved constants for some scenarios. Finally, our simulation results reveal that, in many instances, subsampled frame multiplier matrices exhibit the same ℓ1-reconstruction performance as i.i.d. Gaussian measurement matrices.},
  archive      = {J_TIT},
  author       = {Georg Tauböck and Shristi Rajbamshi and Peter Balazs},
  doi          = {10.1109/TIT.2025.3616817},
  journal      = {IEEE Transactions on Information Theory},
  month        = {10},
  pages        = {1},
  shortjournal = {IEEE Trans. Inf. Theory},
  title        = {Frame multipliers and compressive sensing},
  year         = {2025},
}
</textarea>
</details></li>
</ul>

</body>
</html>
